= DevOps reference implementaton

:numbering!:

An initial reference implementation of the DevOps scenario was undertaken using free and open source software [citation to Calavera project]. Products employed included:
[width="80%",options="header"]
|====
| Product           | Role
| Ubuntu Linux      | operating system
| Vagrant           | virtual environment
| Chef Zero         | virtual server provisioning
| Java              | programming language &
                      interpreter
| JUnit             | automated testing framework
| Apache Ant        | language-specific build tool
| Apache Tomcat     | application server
| git               | source control repository
| Jenkins           | build choreography tool
| Artifactory       | package repository
|====

== Purpose

The purpose of this effort was to ensure that the DevOps scenario was well grounded in technical fundamentals. Abstractions (e.g. "source code control") need to have concrete examples, and interactions suggested by graphical lines need to be traceable to actual system relationships.

The initial version of the pipeline explored the relationship between development, testing, and production environments. The following features were deferred to future versions:

* Source code QA (e.g. static analysis)
* Defect and issue tracking
* Integration testing

== Learnings

There were a number of learnings and insights generated by this effort:

* The importance of representing subject systems and environments in the IT4IT pipeline (e.g. "developer workstation," "production server")

* Clarifying the relationship between artfifact and data object

** Maven coordinates and semantic versioning as emergent metadata standards

* Relationship between source and package repository

=== Systems and environments
The IT4IT reference architecture has not formally represented the computing systems being produced as a result of the IT value chain. However, in attempting to produce a well grounded DevOps reference architecture, it is helpful to represent well known concepts such as a "development workstation," "test server," and "production server." These are intended abstractly. Particular technologies were chosen for the reference implementation (e.g. Java and Tomcat) but alternatives could also be used (e.g. Javascript and node.js).

=== Artifact and data object
As of early 2015, IT4IT is moving towards replacing the term "artifact" with the term "data object." The insight from this reference implementation is that both terms are in fact needed.

The concept of an "artifact" is represented in the simulation by the following files:

* *.java
* *.class
* *.jar
* *.xml

While such artifacts may follow well defined syntax, they are arbitrarily complex. Therefore, a metadata layer emerges to manage them. Metadata is built from concise textual fragments (link:https://en.wikipedia.org/wiki/Variable_(computer_science[scalars] if you will), suitable for data management at scale. Examples include:

* File name and extension
* File location
* Author/developer
* Associated project or release

Many other examples exist.

==== Maven coordinates and semantic versioning
Two important developments in metadata are link:http://maven.apache.org/pom.html#Maven_Coordinates[Maven coordinates] and link:semver.org[semantic versioning].

Full descriptions are available at the links above, but in summary:

*Maven coordinates* consist of the following:

* groupID
* artifactID
* version
* packaging

A fifth attribute, "classifier," is sometimes used.

Semantic versioning can be used as the basis for the version ID; it consists of the following rules:

****

Given a version number MAJOR.MINOR.PATCH, increment the:

1. MAJOR version when you make incompatible API changes,

1. MINOR version when you add functionality in a backwards-compatible manner, and

1. PATCH version when you make backwards-compatible bug fixes. [Semantic versioning citation]
****

The combination of Maven coordinates and semantic versioning should be the foundation for all IT4IT metadata. All major IT management constructs can and should be understood as derivative:

* Service and application IDs
* Release and change IDs
* Work tickets of various types: requirements, scenarios, stories, issues, risks, action items, incidents, service requests.

=== Source and package repositories
Finally, the reference implementation clarified the relationship between source and package repositories. In years past, it has been common practice for compiled binaries to be stored in the same repositories as source code. However, this is no longer deemed best practice. Source repositories 



-30-
