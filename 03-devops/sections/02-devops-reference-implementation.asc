= DevOps reference implementaton

:numbering!:

An initial reference implementation of the DevOps scenario was undertaken using free and open source software [citation to Calavera project]. Products employed included:
[width="80%",options="header"]
|====
| Product           | Role
| Ubuntu Linux      | operating system
| Vagrant           | virtual environment
| Chef Zero         | virtual server provisioning
| Java              | programming language &
                      interpreter
| JUnit             | automated testing framework
| Apache Ant        | language-specific build tool
| Apache Tomcat     | application server
| git               | source control repository
| Jenkins           | build choreography tool
| Artifactory       | package repository
|====

== Purpose

The purpose of this effort was to ensure that the DevOps scenario was well grounded in technical fundamentals. Abstractions (e.g. "source code control") need to have concrete examples, and interactions suggested by graphical lines need to be traceable to actual system relationships.

The initial version of the pipeline explored the relationship between development, testing, and production environments. The following features were deferred to future versions:

* Source code QA (e.g. static analysis)
* Defect and issue tracking
* Integration testing

== Learnings

There were a number of learnings and insights generated by this effort:

* The importance of representing subject systems and environments in the IT4IT pipeline (e.g. "developer workstation," "production server")

* Clarifying the relationship between artfifact and data object

** Maven coordinates and semantic versioning as emergent metadata standards

* Relationship between source and package repository

* Role of testing practices versus test management systems

=== Systems and environments
The IT4IT reference architecture has not formally represented the computing systems being produced as a result of the IT value chain. However, in attempting to produce a well grounded DevOps reference architecture, it is helpful to represent well known concepts such as a "development environment," "build environment," and "production environment." These are intended abstractly. Particular technologies were chosen for the reference implementation (e.g. Java and Tomcat) but alternatives could also be used (e.g. Javascript and node.js).

image:../images/dev-node-2.png[image]

.Example Development Environment

With the increasing power of infrastructure and reach of Cloud, there are many variations on how development environments are constructed. A local physical PC used by a developer may employ a hypervisor (VirtualBox or boot2docker) with development and execution carried out in a virtual layer. The virtual layer increasing is built consistently with production environments through infrastructure as code (e.g. Chef recipes) under shared source control.

Others may still run an execution environment such as Tomcat directly on the base OS, without an intervening virtual layer; however, this approach seems to be falling out of favor.

=== Artifact and data object
As of early 2015, IT4IT is moving towards replacing the term "artifact" with the term "data object." The insight from this reference implementation is that both terms are in fact needed. (This is also consistent with Archimate, which views "artifact" as a Technology Layer construct, while Data Object and its analog Business Object are constructs of the Application and Business Layers, respectively.)

The concept of an "artifact" is represented in the Calavera simulation by the following files:

* *.java
* *.class
* *.jar
* *.xml

While such artifacts may follow well defined syntax, they are arbitrarily complex. Therefore, a metadata layer emerges to manage them. Metadata is built from concise textual fragments, made consistent and suitable for structured data management at scale. Examples include:

* File name and extension
* File location
* Author/developer
* Associated project or release

These attributes are "meta" in the sense that they are not directly required for the runtime functioning of the system, but rather assist in human understanding of its characteristics. Such basic attributes, when aggregated and normalized into schemas, are the foundation of structured IT management and therefore IT4IT.

Many other examples exist, and specific artifacts may have extensive metadata (especially those artifacts having to do with structured data management, e.g. data models and data definition schemas).


==== Maven coordinates and semantic versioning
Two important developments in metadata are link:http://maven.apache.org/pom.html#Maven_Coordinates[Maven coordinates] and link:semver.org[semantic versioning].

Full descriptions are available at the links above, but in summary:

*Maven coordinates* consist of the following:

* groupID
* artifactID
* version
* packaging

A fifth attribute, "classifier," is sometimes used.

*Semantic versioning* can be used as the basis for the version ID; it consists of the following rules:

****

Given a version number MAJOR.MINOR.PATCH, increment the:

1. MAJOR version when you make incompatible API changes,

1. MINOR version when you add functionality in a backwards-compatible manner, and

1. PATCH version when you make backwards-compatible bug fixes. [Semantic versioning citation]
****

The combination of Maven coordinates and semantic versioning should be the foundation for all IT4IT metadata. All major IT management constructs can and should be understood as derivative and/or dependent:

* Service and application IDs
* Release and change IDs
* Work tickets of various types: requirements, scenarios, stories, issues, risks, action items, incidents, service requests.

=== Source and package repositories
Finally, the reference implementation clarified the relationship between source and package repositories. In years past, it has been common practice for compiled binaries to be stored in the same repositories as source code. However, this is no longer deemed best practice. Source repositories should be reserved for symbolic artifacts that can be meaningfully versioned, with differences represented in a human-understandable way. Package repositories in contrast are for binary artifacts that can be deployed.

Package repositories have a further additional role as proxy to the external world of downloadable software. For example, developers are directed to download the approved Java version from the local package repository, rather than going to the Oracle or OpenJDK site and getting the latest version, which may not be suitable for the environment.

As such, package repositories serve as an important control point in reducing variability in the IT pipeline; reducing such variability  is one of the overall goals (G0.6.6) for the Agile workstream.

=== Testing practices versus test management systems



-30-
